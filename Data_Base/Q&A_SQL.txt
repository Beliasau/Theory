1. Ограничитель Primary Key

SQL ограничение – это любое правило, применяемое к столбцу или таблице, которое определяет, какие данные можно в него вносить, а какие – нет
PRIMARY KEY - первичный ключ, ограничение, позволяющее однозначно идентифицировать каждую запись в таблице SQL
Первичные ключи должны содержать UNIQUE значения и не могут содержать значения NULL.
В таблице может быть только один первичный ключ, который может состоять из одного или нескольких полей.








2. SQl и MySQL различия

SQL -  БД

MySql- СУБД









3. Подмножества SQL (DDL, DML, DCL)

язык SQL представляет собой набор операторов, которые делятся на определенные группы и у каждой группы есть свое назначение. В сокращенном виде эти группы называются DDL, DML, DCL и TCL

Data Definition Language (DDL) – это группа операторов определения данных 
(создаем, изменяем и удаляем)
- CREATE – используется для создания объектов базы данных;
- ALTER – используется для изменения объектов базы данных;
- DROP – используется для удаления объектов базы данных

Data Manipulation Language (DML) – это группа операторов для манипуляции данными
- SELECT – осуществляет выборку данных;
- INSERT – добавляет новые данные;
- UPDATE – изменяет существующие данные;
- DELETE – удаляет данные.

Data Control Language (DCL) – группа операторов определения доступа к данным
- GRANT – предоставляет пользователю или группе разрешения на определённые операции с объектом;
- REVOKE – отзывает выданные разрешения;
- DENY– задаёт запрет, имеющий приоритет над разрешением.

Transaction Control Language (TCL) – группа операторов для управления транзакциями.
Транзакция – это команда или блок команд (инструкций), которые успешно завершаются как единое целое, при этом в базе данных все внесенные изменения фиксируются на постоянной основе или отменяются
- BEGIN TRANSACTION – служит для определения начала транзакции;
- COMMIT TRANSACTION – применяет транзакцию;
- ROLLBACK TRANSACTION – откатывает все изменения, сделанные в контексте текущей транзакции;
- SAVE TRANSACTION – устанавливает промежуточную точку сохранения внутри транзакции.










4. Какие СУБД есть

SQL
	MySQL,
	PostgreSQL
	Microsoft SQL Server.	
	Oracle

NoSQL
	MongoDB
	Redis
	DB2
	Microsoft Access









5. ТИпы СУБД


	СУБД по типу хранящихся в них данных
-Реляционные
-Ключ-значение
-Документные
-Графовые
-Колоночные









6. JOIN/SELECT

Для выборки данных из БД в MySQL применяется команда SELECT
SELECT список_столбцов FROM имя_таблицы


SELECT столбцы
FROM таблица1
    [INNER] JOIN таблица2
    ON условие1
    [[INNER] JOIN таблица3
    ON условие2]








7. CHAR/VARCHAR			envarchr????

CHAR(n) – n символов, от 1 до 32767, строковый тип фиксированной длины. Если содержимое поля меньше указанного размера, то оно "выравнивается" (добивается) дополнительными пробелами.

VARCHAR(n) – n символов, от 1 до 32767, строковый тип переменной длины. Пробелы в конце содержимого поля игнорируются.








8. Primary Key свойства

Ограничение PRIMARY KEY однозначно идентифицирует каждую запись в таблице базы данных. Первичные ключи должны содержать UNIQUE значения и не могут содержать значения NULL.
В таблице может быть только один первичный ключ, который может состоять из одного или нескольких полей.

уникальный
NOt Null
автоинкремент












9. ограничения 

ограничения SQL — это правила, применяемые к столбцам данных таблицы. Они используются, чтобы ограничить типы данных, которые могут храниться в таблице. Это обеспечивает точность и надежность данных в базе данных.
Ограничения могут применяться либо на уровне столбцов, либо на уровне таблицы

NOT NULL  — столбец не может иметь значение NULL.

DEFAULT — задает значение по умолчанию для столбца, если оно не указано.

UNIQUE  — все значения в столбце должны быть уникальными.

PRIMARY Key — уникальная идентификация каждой строки/записи в таблице базы данных.

FOREIGN Key — уникально идентифицирует строку/запись в любой другой таблице базы данных.

CHECK — проверочное ограничение CHECK обеспечивает, чтобы все значения в столбце удовлетворяли определенным условиям.Например, чтобы ограничить интервал значений столбца salary , можно создать ограничение CHECK, позволяющее столбцу принимать значения только в интервале от 15 000 до 100 000 долларов.

INDEX 
Индекс – это упорядоченный указатель на записи в таблице. 
Основная функция индексов - обеспечивать быстрый поиск записи в таблице. Индекс не является частью таблицы - это отдельный объект, связанный с таблицей и другими объектами базы данных








10. Foreign Key

Внешние ключи позволяют установить связи между таблицами. Внешний ключ устанавливается для поля (или набора полей)  из зависимой, подчиненной таблицы, и указывает на один из столбцов из главной таблицы. Как правило, внешний ключ указывает на первичный ключ из связанной главной таблицы.
Таблица, содержащая внешний ключ, называется дочерней таблицей, а таблица, содержащая ключ кандидат, называется ссылочной или родительской таблицей.
FOREIGN KEY -  гарантирует ссылочную целостность между родительской и дочерней таблицами







11. целостность данных

Под целостностью баз данных будем понимать некоторый набор требований (правил), которые обеспечивают согласованность (непротиворечивость) данных.нарушение которых приведет к противоречию между базой данных  и предметной областью которую она отражает.

Примеры правил: вес детали должен быть положительным; количество знаков в телефонном номере не должно превышать 15; возраст родителей не может быть меньше возраста их биологического ребёнка и так далее.










12. Кластеризванные и не кластеризованные индексы, разница
Индекс (англ. index) — объект базы данных, создаваемый с целью повышения производительности поиска данных. 
Индекс – это ключ(или таблица), построенный из одного или нескольких столбцов в базе данных, который ускоряет выборку строк из таблицы или представления. 

Упрощённо некластерный индекс можно представить как отдельную таблицу, каждая строка в которой ссылается на одну или несколько строк в таблице с данными. Строки в индексной таблице упорядочены и сгруппированы по значениям ключевых полей.
без индексации будет прочитана и проверена каждая строка, и неудовлетворяющие условию строки просто не попадут в результат. Но прочитаны они будут.
При использовании «обычного», некластерного индекса, задача поиска сильно ускоряется. 
1  индексная таблица весит много меньше таблицы с данными, а значит элементарно может быть прочитана быстрее. 
2  СУБД чаще всего стараются кешировать индексы в оперативную память, которая сама по себе много шустрее жёсткого диска*. 
3  в индексах отсутствуют дублирующиеся строки. А значит, как только мы нашли первое значение, поиск можно прекращать — оно же и последнее. 
4  данные в индексе отсортированы. 
А в-третьих и в-четвёртых вместе позволяют использовать алгоритм бинарного поиска (он же метод деления пополам), эффективность которого многократно превосходит простой перебор.

Кластерный индекс — это древовидная структура данных, при которой значения индекса хранятся вместе с данными, им соответствующими. И индексы, и данные при такой организации упорядочены. При добавлении новой строки в таблицу, она дописывается не в конец файла*, не в конец плоского списка, а в нужную ветку древовидной структуры, соответствующую ей по сортировке.
для каждой таблицы может быть только один кластеризованный индекс.

Для оптимальной производительности запросов индексы обычно создаются на тех столбцах таблицы, которые часто используются в запросах. Для одной таблицы может быть создано несколько индексов. Однако увеличение числа индексов замедляет операции добавления, обновления, удаления строк таблицы, поскольку при этом приходится обновлять сами индексы. Кроме того, индексы занимают дополнительный объем памяти, поэтому перед созданием индекса следует убедиться, что планируемый выигрыш в производительности запросов превысит дополнительную затрату ресурсов компьютера на сопровождение индекса








13. вывести текущую дату 

SELECT NOW();               -- 2018-05-25 21:34:55
SELECT SYSDATE();           -- 2018-05-25 21:34:55
SELECT CURRENT_TIMESTAMP(); -- 2018-05-25 21:32:55
возвращают текущую локальную дату и время на основе системных часов в виде объекта datetime.

SELECT CURRENT_DATE();      -- 2018-05-25
SELECT CURDATE();           -- 2018-05-25
возвращают текущую локальную дату в виде объекта date:

SELECT UTC_DATE();      -- 2018-05-25
возвращает текущую локальную дату относительно GMT









14. денормализация данных
Денормализация — намеренное приведение структуры базы данных в состояние, не удовлетворяющее требованиям нормализации
разработчики с целью нахождения компромисса между устранением аномалий и повышением производительности могут не выполнять требования той или иной нормальной формы, более того, они могут прибегать к  денормализации
Например, в процессе эксплуатации базы данных у Вас возникла необходимость добавить новую характеристику, однако по требованиям определенной нормальной формы Вы должны под эту характеристику создать новую таблицу, однако требования предметной области и требования разрабатываемой системы позволяют этого не делать, при этом Вы четко понимаете, что невынесение этих данных в отдельную таблицу положительно скажется на эксплуатации базы данных. В этом случае Вы выполняете как раз денормализацию.
Также денормализация проводится и в процессе проектирования базы данных, например, когда по требованиям той или иной нормальной формы Вы должны выполнить декомпозицию таблицы, а Вы ее намерено не выполняете, все по тем же причинам, т.е. это удовлетворяет Вашим требованиям

процесс проектирования базы данных иногда называют процессом нахождения компромисса между нормализацией и денормализацией, т.е. между устранением аномалий и повышением производительности.








15. нормализация данных
нормализация — это не процесс целенаправленного приведения базы данных к какой-то определенной нормальной форме, нормализация – это набор принципов, зная и следуя которым, мы можем спроектировать базу данных, структура которой будет гарантировать нам отсутствие определенного рода аномалий.
нет требования, которое обязывало бы нас приводить базу данных к максимально возможной нормальной форме, например, к 5 или 6, и не нужно нормализовать базу данных только для того, чтобы она была нормализована.
Максимально нормализованная база данных – это плохая база данных.

Ненормализованная форма или нулевая нормальная форма (UNF) базы данных
строки в таблицах не должны быть пронумерованы, т.е. порядок строк не имеет значения, так же как не имеет значения порядок столбцов. Т.е. например, если мы поменяем порядок столбцов, или порядок строк, ничего измениться не должно, это не должно ни на что повлиять. Таким образом по реляционной теории мы не можем обратиться к определённой строке или столбцу по ее номеру.

1NF
В таблице не должно быть дублирующих строк
В каждой ячейке таблицы хранится атомарное значение (одно не составное значение)
В столбце хранятся данные одного типа
Отсутствуют массивы и списки в любом виде

2NF
Таблица должна находиться в первой нормальной форме
Таблица должна иметь ключ
Все неключевые столбцы таблицы должны зависеть от полного ключа (в случае если он составной)

3NF
Требование третьей нормальной формы (3NF) заключается в том, чтобы в таблицах отсутствовала транзитивная зависимость.
Транзитивная зависимость – это когда неключевые столбцы зависят от значений других неключевых столбцов.
иными словами неключевые столбцы должны зависеть от первичного ключа












16. Сущности в БД

Сущность в базе данных – это любой объект в базе данных, который можно выделить исходя из сути предметной области для которой разрабатывается эта база данных. Разработчик базы данных должен уметь правильно определять сущности.














17. Индекс в БД

Индекс (англ. index) — объект базы данных, создаваемый с целью повышения производительности поиска данных. 
Индекс – это ключ(или таблица), построенный из одного или нескольких столбцов в базе данных, который ускоряет выборку строк из таблицы или представления. 

Для оптимальной производительности запросов индексы обычно создаются на тех столбцах таблицы, которые часто используются в запросах. Для одной таблицы может быть создано несколько индексов. Однако увеличение числа индексов замедляет операции добавления, обновления, удаления строк таблицы, поскольку при этом приходится обновлять сами индексы. Кроме того, индексы занимают дополнительный объем памяти, поэтому перед созданием индекса следует убедиться, что планируемый выигрыш в производительности запросов превысит дополнительную затрату ресурсов компьютера на сопровождение индекса










18. ТИпы индексов 












19. отличия DROP DELETE TRANCATE   (DROP — удаляет, TRUNCATE — очищает.)

DROP удаляет таблицу из базы данных целиком, вместе со структурой. То есть после выполнения такой команды обратитья к удаленной таблице, например с помощью SELECT, будет уже нельзя.

TRUNCATE удаляет не саму таблицу, а данные, которые эта таблица содержит. TRUNCATE, из-за невозможности использования условий удаления строк через WHERE и отсутствия связанной с этим необходимости сканирования таблицы, является более быстрым аналогом DELETE. Таким образом использование команды TRUNCATE оправдывает себя при необходимости очистить от данных таблицы, содержащие большое (десятки и сотни тысяч) количество строк

DELETE – удаляет одну или несколько строк из таблицы или представления в Microsoft SQL Server, при этом эта операция всегда полностью регистрируется в журнале транзакций, т.е. каждая удаленная строка.

TRUNCATE быстрее тк не записывает в журнал транзакций удаление каждой строки, а делает одну запись об удалении таблицы









20. свойства АСИД (атомарность согласованность изолированность долговечность(стойкость))
ACID (от англ. atomicity, consistency, isolation, durability) 

Требования ACID — набор требований, которые обеспечивают сохранность ваших данных. Что особенно важно для финансовых операций

Atomicity (атомарность)
Атомарность гарантирует, что каждый запрос в транзакции будет выполнен успешно, либо вообще никакой, в случае ошибки одного. Не получится так, что часть запросов выполнятся успешно, а часть с ошибкой. Если хоть одна часть транзакции выполнится с ошибкой, вся транзакция не выполнится. Другими словами под атомарностью можно понимать «всё или ничего».

Consistency (консистентность, согласованность)
Есть такое определение транзакции: «Упорядоченное множество операций, переводящих базу данных из одного согласованного состояния в другое». То есть до выполнения операции и после база остается консистентной (в переводе на русский — согласованной).

Isolation (изолированность)
Гарантирует, что все транзакции будут выполняться изолированно.  Другими словами, одна транзакция не сможет прочитать данные второй транзакции, которая ещё не выполнилась, параллельные транзакции не должны оказывать влияния на её результат.

Durability (стойкость)
Если пользователь получил подтверждение от системы, что транзакция выполнена, он может быть уверен, что сделанные им изменения не будут отменены из-за какого-либо сбоя. Обесточилась система, произошел сбой в оборудовании? На выполненную транзакцию это не повлияет.

Транзакция это единая логическая операция, которая может состоять из одного или нескольких шагов. Например, транзакцией может быть перевод денежных средств между банковскими аккаунтами (снятие денег из одного и пополнение другого). Если в середине такой транзакции возникнет ошибка, может возникнуть большая неконсистентность в данных. Деньги будут вычтены с одного счёта, но не зачислены в другой.
Вот тут и должны быть применены принципы ACID.













21. операторы доступные в SQL

Оператор – это зарезервированное слово, или символ, который используется в SQL выражениях с использованием WHERE для выполнения операции или операций, например, сравнение.

арифметические
+
-
*
/
%	делит левое значение на правое от оператора и возвращает остаток от деления.

логические
ALL	Используется для сравнения значения со всеми значениями в другом множестве значений.
AND	Разрешает существование нескольких условий в условии WHERE выражения SQL.
ANY	Сравнивает значение с любым применимым значением в списке в соответствии с условием.
BETWEEN	Ищет значения в указанном диапазоне.
EXISTS	Ищет запись в таблице, которая соответствует заданным критериям.
IN	Сравнивает значение в списке определённых буквенных значений.
LIKE	Сравнивает значение, которое похоже на определённый шаблон.
NOT	Делает логический оператор противоположным. Например, NOT IN, NOT EXISTS и т.д.
OR	Комбинирует несколько условий в SQL выражении.
IS NULL	Сравнивает значение с NULL.
UNIQUE	Проверяет каждую запись в таблице на уникальность.
 
сравнения
=	
!=	
<>	Проверяет, равны ли значения слева и справа от оператора. Если да – возвращает false, если нет – true	(A <> B) – true.
>	
<	
>=	
<=	
!<	Проверяет, чтобы значение слева было не меньше, чем значение справа от оператора. Если да – возвращает true, если нет – false.	(A !< B) – false
!>	Проверяет, чтобы значение слева было не больше, чем значение справа от оператора. Если да – возвращает true, если нет – false.













22. равны ли  NULL   0    и пробел
NULL указывает на то, что значение неизвестно. NULL отличается от пустого или нулевого значения. Два значения NULL считаются эквивалентными. Сравнения между двумя значениями NULL или между значением NULL и каким-либо иным значением возвращают неизвестную величину, так как значение каждого из значений NULL неизвестно.
Значение NULL обычно указывает на то, что данные неизвестны, неприменимы или будут добавлены позже












23. CROSS JOIN 

Оператор SQL CROSS JOIN формирует таблицу перекрестным соединением (декартовым произведением) двух таблиц. При использовании оператора SQL CROSS JOIN каждая строка левой таблицы сцепляется с каждой строкой правой таблицы. В результате получается таблица со всеми возможными сочетаниями строк обеих таблиц.

SELECT
    column_names [,... n]
FROM
    Table_1 CROSS JOIN Table_2












24. подзапросы в SQL. типы подзапросов
Некоррелирующие
Подзапрос, возвращающий результат или результаты, для получения которых значения указанного столбца не должны соотноситься (коррелировать) со значениями столбцов, указанных в основном запросе, называется некоррелирующим. Результат выполнения некоррелирующего запроса не зависит от значений, возвращаемых основным запросом. Обычно некоррелирующие запросы применяются в запросах, в которых значение определённого столбца сравнивается со значением, возвращаемым подзапросом, в запросах с предикатом IN, кванторными функциями ALL и ANY. Однако уже в запросах с предикатом EXISTS применяются коррелирующие подзапросы.

коррелирующие
Подзапрос, возвращающий результат или результаты, для получения которых значения указанного столбца должны соотноситься (коррелировать) со значениями столбцов, указанных в основном запросе, называется коррелирующим. Иными словами, результат, выполнения подзапроса зависит от значений, возвращаемых основным запросом. Часто коррелирующие подзапросы применяются для получения значений одного из столбцов результирующей таблицы










25. ANY(SOME), ALL

ALL
При использовании  ALL условие в операции сравнения должно быть верно для всех значений, которые возвращаются подзапросом. 
Например, найдем все товары, цена которых меньше чем у любого товара фирмы Apple:

SELECT * FROM Products
WHERE Price < ALL(SELECT Price FROM Products WHERE Manufacturer='Apple')

можно переписать другим образом:
SELECT * FROM Products
WHERE Price < (SELECT MIN(Price) FROM Products WHERE Manufacturer='Apple')

оператор ALL:
x > ALL (1, 2) эквивалентно x > 2
x < ALL (1, 2) эквивалентно x < 1
x = ALL (1, 2) эквивалентно (x = 1) AND (x = 2)
x <> ALL (1, 2) эквивалентно x NOT IN (1, 2)


ANY
Операторы ANY и SOME условие в операции сравнения должно быть истинным для хотя бы одного из значений, возвращаемых подзапросом. По своему действию оба этих оператора аналогичны, поэтому можно применять любой из них. 
Например, в следующем случае получим товары, которые стоят меньше самого дорогого товара компании Apple:

SELECT * FROM Products
WHERE Price < ANY(SELECT Price FROM Products WHERE Manufacturer='Apple')

переписать можно следующим образом:
SELECT * FROM Products
WHERE Price < (SELECT MAX(Price) FROM Products WHERE Manufacturer='Apple')

ANY (а также SOME):
x > ANY (1, 2) эквивалентно x > 1
x < ANY (1, 2) эквивалентно x < 2
x = ANY (1, 2) эквивалентно x IN (1, 2)
x <> ANY (1, 2) эквивалентно (x <> 1) OR (x <> 2)










26. вывести количество строк в таблице базы данных
count()

SELECT COUNT(column_name)
FROM table_name
WHERE condition;














=================================================================================

типы данных в бд

операторы бд
арифмитические
опреаторы сравнения ,,,
логические

order by параметр 

операторы crud в бд
create
insert into
select
delete


отношения=связь=реляции в бд





